import express from 'express';
import { authenticateToken } from '../middleware/auth.js';
import { Session } from '../models/index.js';
import { emitToAll } from '../services/socket.js';
import { syncAllSessions } from '../services/sessionManager.js';
import { 
  createWhatsappJsSession, 
  getWhatsappJsSession, 
  cleanupSession,
  removeWhatsappJsSession,
  shutdownWhatsappJsSession,
  restartWhatsappJsSession,
  listSessions as listWhatsappJsSessions
} from '../services/whatsappjsService.js';
import { 
  createBaileysSession, 
  getBaileysSession, 
  cleanupBaileysSession,
  removeBaileysSession,
  shutdownBaileysSession,
  restartBaileysSession,
  listBaileysSessions
} from '../services/baileysService.js';
import { getSessionsStatus, reactivateSession } from '../controllers/sessionStatusController.js';

const router = express.Router();

// Estado global para armazenar QR codes
const sessionQRs = new Map();
const sessionStatus = new Map();

// Fun√ß√£o para emitir atualiza√ß√µes de sess√µes via WebSocket
const emitSessionsUpdate = async () => {
  try {
    const sessions = await Session.findAll({
      order: [['createdAt', 'DESC']]
    });

    const sessionsWithStatus = sessions.map(session => ({
      ...session.toJSON(),
      currentStatus: sessionStatus.get(session.whatsappId) || session.status,
      qrCode: sessionQRs.get(session.whatsappId) || null
    }));

    console.log('üîÑ Emitindo atualiza√ß√£o de sess√µes via WebSocket:', sessionsWithStatus.length);
    emitToAll('sessions-update', sessionsWithStatus);
  } catch (error) {
    console.error('‚ùå Erro ao emitir atualiza√ß√£o de sess√µes:', error);
  }
};

// GET /api/sessions - Listar todas as sess√µes
router.get('/', authenticateToken, async (req, res) => {
  try {
    const sessions = await Session.findAll({
      where: { userId: req.user.id },
      order: [['createdAt', 'DESC']]
    });

    // Adicionar informa√ß√µes em tempo real
    const sessionsWithStatus = sessions.map(session => ({
      ...session.toJSON(),
      currentStatus: sessionStatus.get(session.whatsappId) || session.status,
      qrCode: sessionQRs.get(session.whatsappId) || null
    }));

    res.json(sessionsWithStatus);
  } catch (error) {
    console.error('Erro ao buscar sess√µes:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
});

// POST /api/sessions - Criar nova sess√£o
router.post('/', authenticateToken, async (req, res) => {
  try {
    const { whatsappId, library } = req.body;

    if (!whatsappId || !library) {
      return res.status(400).json({ error: 'whatsappId e library s√£o obrigat√≥rios' });
    }

    // Verificar se j√° existe uma sess√£o com esse whatsappId
    const existingSession = await Session.findOne({
      where: { whatsappId, userId: req.user.id }
    });

    if (existingSession) {
      return res.status(400).json({ error: 'J√° existe uma sess√£o com este ID' });
    }

    // Criar sess√£o no banco
    const session = await Session.create({
      userId: req.user.id,
      whatsappId,
      library,
      status: 'disconnected'
    });

    // Emitir atualiza√ß√£o de sess√µes via WebSocket
    emitSessionsUpdate();

    res.status(201).json(session);
  } catch (error) {
    console.error('Erro ao criar sess√£o:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
});

// POST /api/sessions/:id/start - Iniciar sess√£o
router.post('/:id/start', authenticateToken, async (req, res) => {
  try {
    const session = await Session.findOne({
      where: { id: req.params.id, userId: req.user.id }
    });

    if (!session) {
      return res.status(404).json({ error: 'Sess√£o n√£o encontrada' });
    }

    // Limpar QR code anterior
    sessionQRs.delete(session.whatsappId);
    sessionStatus.set(session.whatsappId, 'connecting');

    // Emitir atualiza√ß√£o de status via WebSocket
    emitToAll('session-status-update', { 
      sessionId: session.id, 
      status: 'connecting' 
    });

    if (session.library === 'whatsappjs') {
      try {
        const client = await createWhatsappJsSession(
          session.whatsappId,
          (client) => {
            // Quando conectar
            sessionStatus.set(session.whatsappId, 'connected');
            sessionQRs.delete(session.whatsappId);
            session.update({ status: 'connected' });
            console.log(`‚úÖ Sess√£o WhatsApp.js ${session.whatsappId} conectada`);
          },
          (message, client) => {
            // Quando receber mensagem
            console.log('üì® Mensagem recebida WhatsApp.js:', message.body);
          }
        );

        // Capturar QR code
        client.on('qr', async (qr) => {
          try {
            // Converter QR para base64 data URL
            const QRCode = await import('qrcode');
            const qrDataURL = await QRCode.toDataURL(qr);
            sessionQRs.set(session.whatsappId, qrDataURL);
            sessionStatus.set(session.whatsappId, 'qr_ready');
            console.log(`üì± QR Code gerado para sess√£o ${session.whatsappId}`);
          } catch (error) {
            console.error('Erro ao gerar QR Code:', error);
            sessionQRs.set(session.whatsappId, qr); // Fallback para string original
            sessionStatus.set(session.whatsappId, 'qr_ready');
          }
        });

        client.on('disconnected', (reason) => {
          sessionStatus.set(session.whatsappId, 'disconnected');
          sessionQRs.delete(session.whatsappId);
          session.update({ status: 'disconnected' });
          console.log(`üî¥ Sess√£o WhatsApp.js ${session.whatsappId} desconectada: ${reason}`);
        });

        await session.update({ status: 'connecting' });

      } catch (error) {
        console.error(`Erro ao iniciar sess√£o WhatsApp.js ${session.whatsappId}:`, error);
        sessionStatus.set(session.whatsappId, 'error');
        await session.update({ status: 'error' });
        return res.status(500).json({ error: 'Erro ao iniciar sess√£o WhatsApp.js' });
      }

    } else if (session.library === 'baileys') {
      try {
        const sock = await createBaileysSession(
          session.whatsappId,
          async (qr) => {
            try {
              // Converter QR para base64 data URL
              const QRCode = await import('qrcode');
              const qrDataURL = await QRCode.toDataURL(qr);
              sessionQRs.set(session.whatsappId, qrDataURL);
              sessionStatus.set(session.whatsappId, 'qr_ready');
              console.log(`üì± QR Code gerado para sess√£o Baileys ${session.whatsappId}`);
            } catch (error) {
              console.error('Erro ao gerar QR Code:', error);
              sessionQRs.set(session.whatsappId, qr); // Fallback para string original
              sessionStatus.set(session.whatsappId, 'qr_ready');
            }
          },
          (sock) => {
            sessionStatus.set(session.whatsappId, 'connected');
            sessionQRs.delete(session.whatsappId);
            session.update({ status: 'connected' });
            console.log(`‚úÖ Sess√£o Baileys ${session.whatsappId} conectada`);
          },
          (message, sock) => {
            console.log('üì® Mensagem recebida via Baileys:', message);
          }
        );

        await session.update({ status: 'connecting' });

      } catch (error) {
        console.error(`Erro ao iniciar sess√£o Baileys ${session.whatsappId}:`, error);
        sessionStatus.set(session.whatsappId, 'error');
        await session.update({ status: 'error' });
        return res.status(500).json({ error: 'Erro ao iniciar sess√£o Baileys' });
      }
    } else {
      return res.status(400).json({ error: 'Biblioteca n√£o suportada' });
    }

    res.json({ 
      message: 'Sess√£o iniciada com sucesso', 
      status: 'connecting',
      sessionId: session.whatsappId,
      library: session.library
    });

  } catch (error) {
    console.error('Erro ao iniciar sess√£o:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
});

// GET /api/sessions/:id/qr - Obter QR code da sess√£o
router.get('/:id/qr', authenticateToken, async (req, res) => {
  try {
    const session = await Session.findOne({
      where: { id: req.params.id, userId: req.user.id }
    });

    if (!session) {
      return res.status(404).json({ error: 'Sess√£o n√£o encontrada' });
    }

    const qrCode = sessionQRs.get(session.whatsappId);
    const status = sessionStatus.get(session.whatsappId) || session.status;

    res.json({ 
      qrCode, 
      status,
      hasQR: !!qrCode 
    });
  } catch (error) {
    console.error('Erro ao obter QR code:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
});

// DELETE /api/sessions/:id - Deletar sess√£o
router.delete('/:id', authenticateToken, async (req, res) => {
  try {
    const session = await Session.findOne({
      where: { id: req.params.id, userId: req.user.id }
    });

    if (!session) {
      return res.status(404).json({ error: 'Sess√£o n√£o encontrada' });
    }

    console.log(`üóëÔ∏è Deletando sess√£o ${session.whatsappId} (${session.library})`);

    // Parar e limpar a sess√£o se estiver ativa
    try {
      if (session.library === 'whatsappjs') {
        await shutdownWhatsappJsSession(session.whatsappId);
      } else if (session.library === 'baileys') {
        await shutdownBaileysSession(session.whatsappId);
      }
    } catch (error) {
      console.error(`Erro ao desligar sess√£o ${session.whatsappId}:`, error);
      // Continuar com a dele√ß√£o mesmo se houver erro ao desligar
    }

    // Limpar dados em mem√≥ria
    sessionQRs.delete(session.whatsappId);
    sessionStatus.delete(session.whatsappId);

    // Deletar do banco
    await session.destroy();

    console.log(`‚úÖ Sess√£o ${session.whatsappId} deletada com sucesso`);
    res.json({ 
      message: 'Sess√£o deletada com sucesso',
      sessionId: session.whatsappId,
      library: session.library
    });

  } catch (error) {
    console.error('Erro ao deletar sess√£o:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
});

// POST /api/sessions/:id/restart - Reiniciar sess√£o
router.post('/:id/restart', authenticateToken, async (req, res) => {
  try {
    const session = await Session.findOne({
      where: { id: req.params.id, userId: req.user.id }
    });

    if (!session) {
      return res.status(404).json({ error: 'Sess√£o n√£o encontrada' });
    }

    console.log(`üîÑ Reiniciando sess√£o ${session.whatsappId} (${session.library})`);

    // Limpar dados em mem√≥ria
    sessionQRs.delete(session.whatsappId);
    sessionStatus.set(session.whatsappId, 'restarting');

    try {
      if (session.library === 'whatsappjs') {
        const client = await restartWhatsappJsSession(
          session.whatsappId,
          (client) => {
            sessionStatus.set(session.whatsappId, 'connected');
            sessionQRs.delete(session.whatsappId);
            session.update({ status: 'connected' });
            console.log(`‚úÖ Sess√£o WhatsApp.js ${session.whatsappId} reconectada`);
          },
          (message, client) => {
            console.log('üì® Mensagem recebida WhatsApp.js:', message.body);
          }
        );

        client.on('qr', async (qr) => {
          try {
            const QRCode = await import('qrcode');
            const qrDataURL = await QRCode.toDataURL(qr);
            sessionQRs.set(session.whatsappId, qrDataURL);
            sessionStatus.set(session.whatsappId, 'qr_ready');
          } catch (error) {
            console.error('Erro ao gerar QR Code:', error);
            sessionQRs.set(session.whatsappId, qr);
            sessionStatus.set(session.whatsappId, 'qr_ready');
          }
        });

      } else if (session.library === 'baileys') {
        const sock = await restartBaileysSession(
          session.whatsappId,
          async (qr) => {
            try {
              const QRCode = await import('qrcode');
              const qrDataURL = await QRCode.toDataURL(qr);
              sessionQRs.set(session.whatsappId, qrDataURL);
              sessionStatus.set(session.whatsappId, 'qr_ready');
            } catch (error) {
              console.error('Erro ao gerar QR Code:', error);
              sessionQRs.set(session.whatsappId, qr);
              sessionStatus.set(session.whatsappId, 'qr_ready');
            }
          },
          (sock) => {
            sessionStatus.set(session.whatsappId, 'connected');
            sessionQRs.delete(session.whatsappId);
            session.update({ status: 'connected' });
            console.log(`‚úÖ Sess√£o Baileys ${session.whatsappId} reconectada`);
          },
          (message, sock) => {
            console.log('üì® Mensagem recebida via Baileys:', message);
          }
        );
      }

      await session.update({ status: 'connecting' });

      res.json({ 
        message: 'Sess√£o reiniciada com sucesso', 
        status: 'restarting',
        sessionId: session.whatsappId,
        library: session.library
      });

    } catch (error) {
      console.error(`Erro ao reiniciar sess√£o ${session.whatsappId}:`, error);
      sessionStatus.set(session.whatsappId, 'error');
      await session.update({ status: 'error' });
      res.status(500).json({ error: 'Erro ao reiniciar sess√£o' });
    }

  } catch (error) {
    console.error('Erro ao reiniciar sess√£o:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
});

// POST /api/sessions/:id/shutdown - Desligar sess√£o
router.post('/:id/shutdown', authenticateToken, async (req, res) => {
  try {
    const session = await Session.findOne({
      where: { id: req.params.id, userId: req.user.id }
    });

    if (!session) {
      return res.status(404).json({ error: 'Sess√£o n√£o encontrada' });
    }

    console.log(`üîå Desligando sess√£o ${session.whatsappId} (${session.library})`);

    try {
      if (session.library === 'whatsappjs') {
        await shutdownWhatsappJsSession(session.whatsappId);
      } else if (session.library === 'baileys') {
        await shutdownBaileysSession(session.whatsappId);
      }

      // Limpar dados em mem√≥ria
      sessionQRs.delete(session.whatsappId);
      sessionStatus.set(session.whatsappId, 'disconnected');

      await session.update({ status: 'disconnected' });

      res.json({ 
        message: 'Sess√£o desligada com sucesso',
        sessionId: session.whatsappId,
        library: session.library,
        status: 'disconnected'
      });

    } catch (error) {
      console.error(`Erro ao desligar sess√£o ${session.whatsappId}:`, error);
      res.status(500).json({ error: 'Erro ao desligar sess√£o' });
    }

  } catch (error) {
    console.error('Erro ao desligar sess√£o:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
});

// GET /api/sessions/active - Listar sess√µes ativas
router.get('/active', authenticateToken, async (req, res) => {
  try {
    const whatsappJsSessions = listWhatsappJsSessions();
    const baileysSessions = listBaileysSessions();

    const activeSessions = [
      ...whatsappJsSessions.map(sessionId => ({ sessionId, library: 'whatsappjs' })),
      ...baileysSessions.map(sessionId => ({ sessionId, library: 'baileys' }))
    ];

    res.json({
      total: activeSessions.length,
      sessions: activeSessions,
      whatsappjs: whatsappJsSessions.length,
      baileys: baileysSessions.length
    });

  } catch (error) {
    console.error('Erro ao listar sess√µes ativas:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
});

// GET /api/sessions/status - Verificar status de todas as sess√µes
router.get('/status', authenticateToken, getSessionsStatus);

// POST /api/sessions/sync - Sincronizar todas as sess√µes
router.post('/sync', authenticateToken, async (req, res) => {
  try {
    console.log('üîÑ Sincroniza√ß√£o manual solicitada...');
    await syncAllSessions();
    res.json({ message: 'Sincroniza√ß√£o conclu√≠da com sucesso' });
  } catch (error) {
    console.error('‚ùå Erro na sincroniza√ß√£o manual:', error);
    res.status(500).json({ error: 'Erro na sincroniza√ß√£o' });
  }
});

// POST /api/sessions/:sessionId/reactivate - Reativar uma sess√£o
router.post('/:sessionId/reactivate', authenticateToken, reactivateSession);

export default router;
